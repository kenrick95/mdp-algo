<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <style>
* {
    padding: 0;
    margin: 0;
}

        </style>
    </head>
    <body>
        <div style="position:fixed; right:0; top: 0; z-index: 100;">
            <label>Time limit: <input type="time" name="timeLimit" id="timeLimit" value="" placeholder="00:00"></label>
            <br>
            <label>% limit: <input type="number" name="percentageLimit" id="percentageLimit" value="" placeholder="100" min="0" max="100"></label>
            <br>
            <button id="start">Start</button>
        </div>
        <div id="messages" style="position:fixed; right:0; top: 50px; width: 250px; height: 600px; overflow: auto;"></div>
        <div style="width: 100%"><div style="margin: 0 auto; width: 450px;">
        <canvas id="canvas" width="450" height="600" style="background: #eee;">
            
        </canvas>
        </div></div>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function(e) {
            var ws;
            var messageContainer = document.getElementById('messages');
            var canvas = document.getElementById('canvas'),
                context = canvas.getContext('2d');
            var ROW_COUNT = 20, COL_COUNT = 15;
            var map = [];
            for (var y = 0; y < ROW_COUNT; y++) {
                map[y] = [];
                for (var x = 0; x < COL_COUNT; x++) {
                    map[y][x] = 0;
                }
            }

            function getStyle(cell) {
                /**
                - 0: unexplored
                - 1: explored
                - 2: obstacle
                - 3: robot body
                - 4: robot head
                - 5: robot center
                - 6: start
                - 7: goal
                - 8: explored path
                - 9: optimum path
                 */
                switch(cell) {
                    case 0: return "#ddd";
                    case 1: return "#fff";
                    case 2: return "#111";
                    case 3: return "#2ECC40";
                    case 4: return "#01FF70";
                    case 5: return "#2ECC40";
                    case 6: return "#FFDC00";
                    case 7: return "#FF851B";
                    case 8: return "#39CCCC";
                    case 9: return "#0074D9";
                    default: return "#ddd"; // 0
                }
            }
            function draw(map) {
                // console.log(map);

                context.save();
                context.strokeStyle = "#333";
                for (var y = 0; y < ROW_COUNT; y++) {
                    for (var x = 0; x < COL_COUNT; x++) {

                        context.beginPath();
                        context.fillStyle = getStyle(map[y][x]);
                        context.rect(30 * x, 30 * y, 30, 30);
                        context.fill();
                        context.stroke();
                    }
                }
                context.restore();
            }
            draw(map);
            var timeLimit = 1 * 60 * 60 * 1000;
            var Timer = function () {
                this.startTime = null;
                this.currentTime = new Date();
            };
            Timer.prototype.start = function () {
                this.startTime = new Date();
            };

            Timer.prototype.tick = function (check) {
                this.currentTime = new Date();
                if (this.currentTime - this.startTime > timeLimit) {
                    this.end();
                    return false;
                }
                window.requestAnimationFrame(this.tick.bind(this));
            };
            Timer.prototype.end = function() {
                var r = new XMLHttpRequest();
                r.open("GET", "/stop/", true);
                r.onreadystatechange = function () {
                  if (r.readyState != 4 || r.status != 200) return;
                    messageContainer.innerHTML += "<br>" + r.responseText;
                };
                r.send();
            };
            var timer = new Timer();

            messageContainer.innerHTML = "";
            document.getElementById("timeLimit").addEventListener("change", function(e) {
                var timeString = this.value;
                var len = this.value.length;
                // convert sting (mm:ss) to seconds value
                
                // enforce mm:ss
                timeLimit = parseInt(timeString[0], 10) * 600 +
                    parseInt(timeString[1], 10) * 60 +
                    parseInt(timeString[3], 10) * 10 +
                    parseInt(timeString[4], 10);

                timeLimit *= 1000; // convert to ms
                console.log(timeLimit);
            });
            document.getElementById("start").addEventListener('click', function(e) {
                var r = new XMLHttpRequest();
                var percentage = document.getElementById('percentageLimit').value || 0;
                r.open("GET", "/start/" + percentage, true);
                r.onreadystatechange = function () {
                  if (r.readyState != 4 || r.status != 200) return;
                    messageContainer.innerHTML += "<br>" + r.responseText;
                };
                r.send();

                timer.start();
                timer.tick();
            });
            ws = new WebSocket("ws://localhost:8888/ws?Id=" + Math.floor(Math.random() * 1000000));
            ws.onopen = function() {
                ws.send("Initializing connection");
                messageContainer.innerHTML += "<br>Connection is opened...";
            };
            ws.onmessage = function (evt) { 
                var received_msg = evt.data;
                //messageContainer.innerHTML += "<br>Message is received: " + received_msg;
                var data = JSON.parse(evt.data);
                if (data.type === "map") {
                    var map = data.map;
                    draw(map);
                } else if (data.type === "info") {
                    messageContainer.innerHTML += "<br>" + received_msg;
                }
            };
            ws.onclose = function() { 
                messageContainer.innerHTML += "<br>Connection is closed...";
            };

            // 20 x 15
            // goal and end always at corner, but may be different corners
        });
        </script>
    </body>
</html>